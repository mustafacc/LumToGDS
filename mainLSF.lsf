#How to use:
#1. Press F5 or Run
#The script will first find all geometry objects and store them to a 'metadata' variable (LIB_GDS_extract)
#The script will then initiate a wizard to allow the user to input layer information corresponding to the detected material + geometry heights
#The Wizard will then prompt a filename and save to it.

#Exported GDS only readable in Klayout 0.26 or earlier
#Please use the python3.9 method or converter script if 
#you wish to use it for later Klayout versions.

#Script has be in the library folder to properly call other library files.
thispath=splitstring(currentscriptname,"mainLSF.lsf");
cd(thispath{1});

#DEFAULT SETTINGS for Lumerical's library
#n_circle = 64;	# number of sides to use for circle approximation (64 by default).
#n_ring = 64;	# number of slices to use for ring approximation (64 by default).
#n_custom = 64;	# number of slices to use for custom approximation (64 by default).
#n_wg = 64;		# number of slices to use for waveguide approximation (64 by default). 
#round_to_nm = 1;	# round the z and z span to the nearest integer of nm
#grid = 1e-9;	# Round XY coordinates to this grid in SI. Will also update the database units if grid < 
#max_objects = 10000;	# the maximum number of objects within the workspace (Increasing this will increase export time)
#Lumerical_GDS_autoexp_functions; #loads the necessary functions
GDSexport_core;
LUM_auto_detect;

#FUNCTIONS
function draw_entry_page(i,metadata,dupdata){
    if(i==1){newwizardpage("Next");}
    else{newwizardpage("Next","Back");}
    
    wizardwidget("label","Entry "+num2str(i)+endl);
    if(metadata.material{i} == "<Object defined dielectric>"){
        wizardwidget("label","Material:\tIndex = "+metadata.index{i});
    }
    else{
        wizardwidget("label","Material:\t"+metadata.material{i});
    }
    wizardwidget("label","Z max:\t\t"+num2str(metadata.zmax{i}*1e6)+"\t[um]");
    wizardwidget("label","Z min:\t\t"+num2str(metadata.zmin{i}*1e6)+"\t[um]");
    wizardwidget("label","Z pos:\t\t"+num2str((metadata.zmax{i}+metadata.zmin{i})/2*1e6)+"\t[um]");    
    wizardwidget("label",endl);
    if(any(i==dupdata(:,2))){wizardwidget("label","<This object has a shared layer>");}
    else{    
    wizardwidget("checkbox","Include Layer",1);
    wizardwidget("number","Layer Number:",i);
    wizardwidget("number","DataType Number:",0); 
    }                          
}

metadata = get_objects_info();
dupdata = get_duplicate_layers(metadata);
dupe = dupdata(:,2);
ori = dupdata(:,1);
#metadata = format_layerdata(objectinfo,dupdata(:,2));
#layer_def = matrix(length(metadata.material),4); #exported to the gds generator script
layer_def_list = cell(length(metadata.material));

#Create Wizard
newwizard(500,200,"Stack Definition Wizard");
wizardoption("fontsize",16);
wizardoption("fieldwidth",150);
wizardoption("fieldheight",20);
wizardoption("margin",20);
newwizardpage("Continue");

wizardwidget("label",endl+"The following layer information was auto-detected:"+endl);
wizardwidget("label","Unique Objects: "+num2str(length(metadata.material))); #list number of layers
wizardwidget("label","Materials Detected:"+endl); #list all materials used in the file
for (i=1;i<=length(metadata.material);i=i+1){
   if(!any(i==dupdata(:,2))){
       #wizardwidget("label",metadata.material{i});
       if (metadata.material{i} == "<Object defined dielectric>"){
           wizardwidget("label",">\tIndex = "+metadata.index{i});  
       }
       else{
           wizardwidget("label",">\t"+metadata.material{i});
       }
       }
}
out = runwizard; #0 = cancel, 1 is button 1, -1 is button 2
if(out==0){
   killwizard;
}

#Draw number of pages based on how many entries
#if back is pressed, load previous page via value of i
for(i=1;i<=length(metadata.material);0){
    draw_entry_page(i,metadata,dupdata);
    out = runwizard; #0 = cancel, 1 is button 1, -1 is button 2
    
    if(out==0){
    killwizard;
   }

   else if((out==1)){
         if(any(i==dupdata(:,2))){
             for(j=1;j<=length(dupe);j=j+1){
                 if(i==dupe(j)){
                      #layer_def(i,1) = layer_def(ori(j),1);
                      #layer_def(i,2) = layer_def(ori(j),2);
	               #layer_def(i,3) = layer_def(ori(j),3);        
	               #layer_def(i,4) = layer_def(ori(j),4);
	               layer_def_list{i} = struct;
	               layer_def_list{i}.layer = layer_def_list{ori(j)}.layer;
	               layer_def_list{i}.z = layer_def_list{ori(j)}.z;
	               layer_def_list{i}.material = layer_def_list{ori(j)}.material; 
                     }                 
                 }
             }         
         else{
	  #layer_def(i,1) = wizardgetdata(2);
	  #layer_def(i,2) = wizardgetdata(3);
	  #layer_def(i,3) = metadata.zmin{i};        
	  #layer_def(i,4) = metadata.zmax{i};
	  layer_def_list{i} = struct;
	  layer_def_list{i}.layer = num2str(wizardgetdata(2))+":"+num2str(wizardgetdata(3));
	  layer_def_list{i}.z = (metadata.zmin{i}+metadata.zmax{i})/2;
         if (metadata.material{i} == "<Object defined dielectric>"){	  
	      layer_def_list{i}.material = metadata.index{i};
         }
         else{
             layer_def_list{i}.material = metadata.material{i};
         }
         }
	  i=i+1;       
   }

   else if((out==-1)){
	  #i=i-1; #might be a bug? delete this if all works well.
	  if(i!=0){
		 i=i-1;
		 }
   }
}

#final confirmation page
newwizardpage("Export to GDS");
wizardwidget("label","Export Configuration (Leave blank for defaults)");
wizardwidget("string","GDS Filename\t(\"output.gds\"):","output.gds");
wizardwidget("string","Top Cell\t(\"model\"):",",model");
wizardwidget("label","==Layers Export Information==");
#wizardwidget("label","Name\tLy\tDat\tZmin\tZmax");
wizardwidget("label","Name\tLayer\tZpos");
for (i=1;i<=length(layer_def_list);i=i+1){
   #wizardwidget("label",metadata.name{i}+"\t"+num2str(layer_def(i,1))+"\t"+num2str(layer_def(i,2))+"\t"+num2str(layer_def(i,3)*1e6)+"\t"+num2str(layer_def(i,4)*1e6)); 
   wizardwidget("label",metadata.name{i}+"\t"+layer_def_list{i}.layer+"\t"+num2str(layer_def_list{i}.z)); 
}

out = runwizard;
if(out==0){
   killwizard;
}
else if(out==1){
	if (wizardgetdata(1)!=""){gds_filename_temp = "output/"+wizardgetdata(1);}
	else{gds_filename_temp = "output/TEMP_output";}
	if (wizardgetdata(2)!=""){top_cell = wizardgetdata(2);}
	else{top_cell = "model";}

	killwizard;

	#For scenarios where 2 objects have same height, we disable and enable as we export.       
	for (a=1;a<=length(metadata.name);a=a+1){
		select(metadata.name{a});
		set("enabled",false);           
	}	

	#layer_def_temp = layer_def_list; #write the layer values to a temp variable
	for (a=1;a<=length(metadata.name);a=a+1){ #cannot use i, it is used by the encrypted function and cleared
		#layer_def = layer_def_temp(a,:); #the export function must use "layer_def" as the variable	
               layer_def = cell(1);
               layer_def{1} = layer_def_list{a};		
		gds_filename = gds_filename_temp+num2str(a)+".gds";	
                             
		select(metadata.name{a});
		set("enabled",true);		
		#print(layer_def);
		#Lumerical_GDS_autoexp; #this executes the gds export encrypted function
		
                f_name = gdsopen(gds_filename);
                level_list = get_level_list("::model::");
                verbose = false;
                try{
                stck = extract_gds(level_list, layer_def, 0, f_name, verbose);
                }
                gdsclose(f_name);
		
		select(metadata.name{a});		
		set("enabled",false);	
	}
}
#reset back to original
for (a=1;a<=length(metadata.name);a=a+1){
	select(metadata.name{a});
	set("enabled",true);           
}	
clearfunctions;
clear(gds_filename);
clear(gds_filename_temp);
#clear(grid);
#clear(layer_no);
#clear(max_objects);
#clear(n_circle);
#clear(n_custom);
#clear(n_ring);
#clear(n_wg);
#clear(orig_layer_def);
clear(out);
#clear(round_to_nm);
clear(top_cell);
clear(layer_def_list);
#clear(layer_def_temp);
clear(a);
clear(metadata);
clear(dupdata);
clear(dupe);
clear(ori);
clear(j);
clear(f_name);
clear(i);
clear(layer_def);
clear(level_list);
clear(stck);
clear(thispath);
clear(verbose);

python("PY_klayout.py"); #Converts and merges the output file to be usable with up to date Klayout versions