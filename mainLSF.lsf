#How to use:
#1. Press F5 or Run
#The script will first find all geometry objects and store them to a 'metadata' variable (LIB_GDS_extract)
#The script will then initiate a wizard to allow the user to input layer information corresponding to the detected material + geometry heights
#The Wizard will then prompt a filename and save to it.

#Exported GDS only readable in Klayout 0.26 or earlier
#Please use the python3.9 method or converter script if 
#you wish to use it for later Klayout versions.

#Script has be in the library folder to properly call other library files.
thispath=splitstring(currentscriptname,"mainLSF.lsf");
cd(thispath{1});

#DEFAULT SETTINGS for Lumerical's library
n_circle = 64;	# number of sides to use for circle approximation (64 by default).
n_ring = 64;	# number of slices to use for ring approximation (64 by default).
n_custom = 64;	# number of slices to use for custom approximation (64 by default).
n_wg = 64;		# number of slices to use for waveguide approximation (64 by default). 
round_to_nm = 1;	# round the z and z span to the nearest integer of nm
grid = 1e-9;	# Round XY coordinates to this grid in SI. Will also update the database units if grid < 
max_objects = 10000;	# the maximum number of objects within the workspace (Increasing this will increase export time)
Lumerical_GDS_autoexp_functions; #loads the necessary functions
LUM_auto_detect;

#FUNCTIONS
function draw_entry_page(i,metadata,dupdata){
    if(i==1){newwizardpage("Next");}
    else{newwizardpage("Next","Back");}
    
    wizardwidget("label","Entry "+num2str(i)+endl);
    wizardwidget("label","Material:\t\t"+metadata.material{i});
    wizardwidget("label","Dimension, z max:\t"+num2str(metadata.zmax{i}*1e6)+" [um]");
    wizardwidget("label","Dimension, z min:\t"+num2str(metadata.zmin{i}*1e6)+" [um]");
    wizardwidget("label",endl);
    if(any(i==dupdata(:,2))){wizardwidget("label","<This object has a shared layer>");}
    else{    
    wizardwidget("checkbox","Include Layer",1);
    wizardwidget("number","Layer Number:",i);
    wizardwidget("number","DataType Number:",0); 
    }                          
}

metadata = get_objects_info();
dupdata = get_duplicate_layers(metadata);
dupe = dupdata(:,2);
ori = dupdata(:,1);
#metadata = format_layerdata(objectinfo,dupdata(:,2));
layer_def = matrix(length(metadata.material),4); #exported to the gds generator script

#Create Wizard
newwizard(500,200,"Stack Definition Wizard");
wizardoption("fontsize",16);
wizardoption("fieldwidth",150);
wizardoption("fieldheight",20);
wizardoption("margin",20);
newwizardpage("Continue");

wizardwidget("label",endl+"The following layer information was auto-detected:"+endl);
wizardwidget("label","Total Layers: "+num2str(length(metadata.material))); #list number of layers
wizardwidget("label","Layer Materials Detected:"+endl); #list all materials used in the file
for (i=1;i<=length(metadata.material);i=i+1){
   if(!any(i==dupdata(:,2))){
       wizardwidget("label",metadata.material{i});
       }
}
out = runwizard; #0 = cancel, 1 is button 1, -1 is button 2
if(out==0){
   killwizard;
}

#Draw number of pages based on how many entries
#if back is pressed, load previous page via value of i
for(i=1;i<=length(metadata.material);0){
    draw_entry_page(i,metadata,dupdata);
    out = runwizard; #0 = cancel, 1 is button 1, -1 is button 2
    
    if(out==0){
    killwizard;
   }

   else if((out==1)){
         if(any(i==dupdata(:,2))){
             for(j=1;j<=length(dupe);j=j+1){
                 if(i==dupe(j)){
                      layer_def(i,1) = layer_def(ori(j),1);
                      layer_def(i,2) = layer_def(ori(j),2);
	               layer_def(i,3) = layer_def(ori(j),3);        
	              layer_def(i,4) = layer_def(ori(j),4);
                     }                 
                 }
             }         
         else{
	  layer_def(i,1) = wizardgetdata(2);
	  layer_def(i,2) = wizardgetdata(3);
	  layer_def(i,3) = metadata.zmin{i};        
	  layer_def(i,4) = metadata.zmax{i};
         }
	  i=i+1;       
   }

   else if((out==-1)){
	  #i=i-1; #might be a bug? delete this if all works well.
	  if(i!=0){
		 i=i-1;
		 }
   }
}

#final confirmation page
newwizardpage("Export to GDS");
wizardwidget("label","Export Configuration (Leave blank for defaults)");
wizardwidget("string","GDS Filename\t(\"output.gds\"):","output.gds");
wizardwidget("string","Top Cell\t(\"model\"):",",model");
wizardwidget("label","==Layers Export Information==");
wizardwidget("label","Name\t\tLy\tDat\tZmin\tZmax");
for (i=1;i<=length(layer_def(:,1));i=i+1){
   wizardwidget("label",metadata.name{i}+"\t"+num2str(layer_def(i,1))+"\t"+num2str(layer_def(i,2))+"\t"+num2str(layer_def(i,3)*1e6)+"\t"+num2str(layer_def(i,4)*1e6)); 
}

out = runwizard;
if(out==0){
   killwizard;
}
else if(out==1){
	if (wizardgetdata(1)!=""){gds_filename_temp = "output/"+wizardgetdata(1);}
	else{gds_filename_temp = "output/TEMP_output";}
	if (wizardgetdata(2)!=""){top_cell = wizardgetdata(2);}
	else{top_cell = "model";}

	killwizard;

	#For scenarios where 2 objects have same height, we disable and enable as we export.       
	for (a=1;a<=length(metadata.name);a=a+1){
		select(metadata.name{a});
		set("enabled",false);           
	}	

	layer_def_temp = layer_def; #write the layer values to a temp variable
	for (a=1;a<=length(metadata.name);a=a+1){ #cannot use i, it is used by the encrypted function and cleared
		layer_def = layer_def_temp(a,:); #the export function must use "layer_def" as the variable	
		gds_filename = gds_filename_temp+num2str(a)+".gds";	
                             
		select(metadata.name{a});
		set("enabled",true);		
		#print(layer_def);
		Lumerical_GDS_autoexp; #this executes the gds export encrypted function
		select(metadata.name{a});		
		set("enabled",false);	
	}
}
#reset back to original
for (a=1;a<=length(metadata.name);a=a+1){
	select(metadata.name{a});
	set("enabled",true);           
}	
clearfunctions;
clear(gds_filename);
clear(gds_filename_temp);
clear(grid);
clear(layer_no);
clear(max_objects);
clear(n_circle);
clear(n_custom);
clear(n_ring);
clear(n_wg);
clear(orig_layer_def);
clear(out);
clear(round_to_nm);
clear(top_cell);
clear(layer_def);
clear(layer_def_temp);
clear(a);
clear(metadata);
clear(dupdata);
clear(dupe);
clear(ori);
clear(j);

python("PY_klayout.py"); #Converts and merges the output file to be usable with up to date Klayout versions